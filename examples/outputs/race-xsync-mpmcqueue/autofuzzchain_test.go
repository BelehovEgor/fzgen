package xsyncqueuefuzz

// generated by:
//     fzgen -chain -parallel -pkg github.com/thepudds/fzgen/examples/inputs/race-xsync-mpmcqueue
// and then modified as follows:
//     1. restricted the capacity to be in the interval [1,4096].
//     2. enforce a large enough capacity prior to any Enqueue.
//     2. placed an Enqueue prior to every Dequeue and TryDequeue, to avoid possibly blocking on Dequeue.
import (
	"testing"

	xsyncqueue "github.com/thepudds/fzgen/examples/inputs/race-xsync-mpmcqueue"
	"github.com/thepudds/fzgen/fuzzer"
)

func Fuzz_NewMPMCQueue_Chain(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var capacity int
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&capacity)

		if capacity < 0 {
			capacity = -capacity
		}
		if capacity%2 == 0 {
			capacity = 1
		} else {
			capacity = 1 + capacity%4096
		}

		target := xsyncqueue.NewMPMCQueue(capacity)

		var allowDequeue, allowEnqueue bool
		if capacity > 256*10 {
			// We should have enough capacity to avoid blocking on an Enqueue.
			// This check relies on current knowledge of fzgen.Fuzzer implementation.
			// Worst case is a loop of 256 with 10 steps being executed in parallel that
			// are all Enqueue or TryEnqueue without any Dequeue or TryDequeue,
			// which would place 256*10 elements into the queue.
			allowEnqueue = true
		}

		fz.Fill(&allowDequeue)
		if !allowEnqueue {
			// For Dequeue, we only allow it if we always proceed every Dequeue and TryDequeue
			// with an Enqueue so that it is not possible to have more Dequeues than elements inserted so far,
			// so if Enqueue is disallowed, we disallow Dequeue.
			allowDequeue = false
		}

		steps := []fuzzer.Step{
			fuzzer.Step{
				Name: "Fuzz_XSyncMPMCQueue_Enqueue",
				Func: func(item int8) {
					if allowEnqueue {
						target.Enqueue(item)
					}
				}},
			fuzzer.Step{
				Name: "Fuzz_XSyncMPMCQueue_Enqueue_Dequeue",
				Func: func(item int8) int8 {
					if allowEnqueue && allowDequeue {
						// We should have enough capacity to avoid blocking. See comment above.
						target.Enqueue(item)
						return target.Dequeue()
					}
					return 0
				}},
			fuzzer.Step{
				Name: "Fuzz_XSyncMPMCQueue_TryDequeue",
				Func: func() (int8, bool) {
					if allowDequeue {
						// To avoid a later Dequeue from possibly blocking, TryDequeue here
						// must have a paired Enqueue to ensure there is always at least 1 elem
						// for a subsequent Dequeue.
						target.Enqueue(0)
					}
					return target.TryDequeue()
				}},
			fuzzer.Step{
				Name: "Fuzz_XSyncMPMCQueue_TryEnqueue",
				Func: func(item int8) bool {
					return target.TryEnqueue(item)
				}},
		}

		// Execute a specific chain of steps, with the count, sequence and arguments controlled by fz.Chain
		fz.Chain(steps, fuzzer.ChainOptParallel)
	})
}
